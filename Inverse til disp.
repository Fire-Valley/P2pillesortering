import numpy as np

# Længder på de forskellige dele af robotten
L = {
    'world': {'l': 90},
    'hop': {'l': 45},
    'base': {'l': 45},
    'lower_arm': {'l': 95},
    'parallel_arm': {'l': 120, 's1': 30, 's2': 20},
    'elbow': {'l': 18},
    'upper_arm': {'l': 175},
    'wrist': {'l': 70}
}
# Dette er vores DH parameter taget fra vores Forward kinematik
dh_params = [
    {'theta': 0, 'd': L['world']['l'] + L['hop']['l'], 'a': L['base']['l'], 'alpha': 0},
    {'theta': 0, 'd': L['lower_arm']['l'], 'a': 0, 'alpha': -np.pi / 2},
    {'theta': 0, 'd': L['upper_arm']['l'], 'a': 0, 'alpha': 0},
    {'theta': 0, 'd': 0, 'a': L['elbow']['l'], 'alpha': -np.pi / 2},
    {'theta': 0, 'd': 0, 'a': 0, 'alpha': np.pi / 2},
    {'theta': 0, 'd': L['wrist']['l'], 'a': 0, 'alpha': -np.pi / 2}
]

# Vi begynder at udregne vores theta værdier
def geometric_inverse_kinematic(desired_position, L):
    x, y, z = desired_position

    # Udregning af theta1
    theta1_rad = np.arctan2(y, x)
    theta1_deg = np.degrees(theta1_rad)

    # Links
    L1 = L['lower_arm']['l'] + L['elbow']['l']
    L2 = L['upper_arm']['l'] + L['wrist']['l']

    #ystart er en målt værdi
    ystart = 200

    nyy = desired_position[1] - ystart

    # Vi udregner og bestemmer hvilken vej vores arm skal bevæge sig.
    if desired_position[1] > ystart:
        L4 = np.sqrt(((ystart + nyy))**2 + (L1**2))
    else:
        L4 = np.sqrt(((ystart - nyy))**2 + (L1**2))

    # Udregning af L3 - Hypotenusen
    L3 = np.sqrt(L4 ** 2 + L2 ** 2)

    # Udregning af theta 2
    theta2_rad = np.arccos((L4**2 + L3**2 - L2**2) / (2 * L4 * L3))
    theta2_deg = np.degrees(theta2_rad)

    #Theta3 får vi fra vores forward kinematik program
    theta3_deg = 65
    theta3_rad = np.radians(theta3_deg)

    #Opstilling af den totale transformations matrix.
    def transformation_matrix(d, a, alpha, theta):
        return np.array([
            [np.cos(theta), -np.sin(theta), 0, a],
            [np.sin(theta) * np.cos(alpha), np.cos(theta) * np.cos(alpha), -np.sin(alpha), np.sin(alpha) * d],
            [np.sin(theta) * np.sin(alpha), np.cos(theta) * np.sin(alpha), np.cos(alpha), np.cos(alpha) * d],
            [0, 0, 0, 1]
        ])

    #Vi bestemmer de tre første rækker af vores DH og ganger dem sammen
    T01 = transformation_matrix(L['world']['l'] + L['hop']['l'], L['base']['l'], 0, theta1_rad)
    T12 = transformation_matrix(L['lower_arm']['l'], 0, -np.pi / 2, theta2_rad)
    T23 = transformation_matrix(L['upper_arm']['l'], 0, 0, theta3_rad)

    T03 = T01 @ T12 @ T23

    # Vi bestemmer vores transformation for alle vores DH parametere og fjerner T03 så vi kune har T36W tilbage
    T06W = [transformation_matrix(d['d'],d['a'], d['alpha'],d['theta']) for d in dh_params]

    T36W = np.linalg.inv(T03) @ T06W

    #Udregning af theta 4, 5 og 6
    theta5_rad = np.arccos(T36W[2][3])
    theta5_deg = np.degrees(theta5_rad)

    theta4_rad = np.arctan2(T36W[1][3] * np.sin(theta5_rad), -T36W[0][3] * np.sin(theta5_rad))
    theta4_deg = np.degrees(theta4_rad)

    theta6_rad = np.arctan2(-T36W[2][1] * np.sin(theta5_rad), T36W[2][0] * np.sin(theta5_rad))
    theta6_deg = np.degrees(theta6_rad)


    return theta1_deg, theta2_deg, theta3_deg, theta4_deg, theta5_deg, theta6_deg

# Definer desired position ud fra x, y og z værdier
desired_position = (-105, 270, 105)

# Udregning af inverse kinematik
theta1_deg, theta2_deg, theta3_deg, theta4_deg, theta5_deg, theta6_deg = geometric_inverse_kinematic(desired_position, L)

# Print for theta værdierne
print("Theta values for Inverse Kinematic:")
print("Theta1 in Degrees:", theta1_deg)
print("Theta2 in Degrees:", theta2_deg)
print("Theta3 in Degrees:", theta3_deg)
print("Theta4 in Degrees:", theta4_deg)
print("Theta5 in Degrees:", theta5_deg)
print("Theta6 in Degrees:", theta6_deg)
