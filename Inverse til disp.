import numpy as np
import sympy as sp
# Længder på de forskellige dele af robotten
L = {
    'world': {'l': 90},
    'hop': {'l': 45},
    'base': {'l': 45},
    'lower_arm': {'l': 95},
    'parallel_arm': {'l': 120, 's1': 30, 's2': 20},
    'elbow': {'l': 18},
    'upper_arm': {'l': 157},
    'wrist': {'l': 75}
}
theta1, theta2, theta3, theta4, theta5, theta6 = sp.symbols('theta1 theta2 theta3 theta4 theta5 theta6')

# Dette er vores DH parameter taget fra vores Forward kinematik
dh_params = [
    {'theta': 0, 'd': L['world']['l'], 'a': 0, 'alpha': 0},
    {'theta': 0, 'd': L['hop']['l'], 'a': L['base']['l'], 'alpha': 0},
    {'theta': 0, 'd': 0, 'a': L['lower_arm']['l'], 'alpha': -90},
    {'theta': 0, 'd': L['upper_arm']['l'] , 'a': 0, 'alpha': 0},
    {'theta': 0, 'd': 0, 'a': L['elbow']['l'], 'alpha': 90},
    {'theta': 0, 'd': 0, 'a': 0, 'alpha': 90},
    {'theta': 0, 'd': 0, 'a': 0, 'alpha': -90},
    {'theta': 0, 'd': L['wrist']['l'], 'a': 0, 'alpha': 0}
]

# Vi begynder at udregne vores Theta værdier
def geometric_inverse_kinematic(desired_position, L):
    x, y, z = desired_position

    # Udregning af Theta1
    theta1_rad = np.arctan2(y, x)
    theta1_deg = np.degrees(theta1_rad)

    # Links
    L1 = L['lower_arm']['l'] + L['elbow']['l']
    L2 = L['upper_arm']['l'] + L['wrist']['l']

    # Udregn Theta 2
    L0 = (x**2 + y**2)**0.5
    a = L0-45
    b = z-135
    theta2_rad = np.arccos((L1**2 + (np.sqrt(a**2+b**2))**2 - L2**2) / (2 * L1 * np.sqrt(a**2+b**2))) + np.arctan2(z-135, L0-45)
    theta2_deg = np.degrees(theta2_rad)

    #Udregning af Theta 3
    Nya = (x**2 + y**2)**0.5
    Nyb = z-135
    NyL2 = (18**2+157**2)**0.5
    c = (Nya**2+Nyb**2)**0.5
    C = np.clip((95**2 + NyL2**2 - c**2)/(2*95*NyL2), -1, 1)
    Tre = np.degrees(np.arccos(18/NyL2))
    theta3_deg = Tre + np.degrees(np.pi - np.arccos(C))
    theta3_deg = 90 - theta3_deg
    # 6.54 er et offset på Theta 3
    theta3_deg -= 6.54
    theta3_rad = np.radians(theta3_deg)


    #Udregning af Theta 4, 5 og 6 med roll, pitch og yaw
    roll = 0        # Gamma
    pitch = 0   # Beta
    yaw = 0    # Alpha


    Rz = np.array([
        [np.cos(yaw), -np.sin(yaw), 0],
        [np.sin(yaw), np.cos(yaw), 0],
        [0, 0, 1]
    ])

    Ry = np.array([
        [np.cos(pitch), 0, np.sin(pitch)],
        [0, 1, 0],
        [-np.sin(pitch), 0, np.cos(pitch)]
    ])

    Rx = np.array([
        [1, 0, 0],
        [0, np.cos(roll), -np.sin(roll)],
        [0, np.sin(roll), np.cos(roll)]
    ])

    R = Rz @ Ry @ Rx

    #Opstilling af den totale transformations matrix.
    def transformation_matrix(d, a, alpha, theta):
        return np.array([
            [np.cos(theta), -np.sin(theta), 0, a],
            [np.sin(theta) * np.cos(alpha), np.cos(theta) * np.cos(alpha), -np.sin(alpha), np.sin(alpha) * d],
            [np.sin(theta) * np.sin(alpha), np.cos(theta) * np.sin(alpha), np.cos(alpha), np.cos(alpha) * d],
            [0, 0, 0, 1]
        ])

    #Vi bestemmer de tre første rækker af vores DH og ganger dem sammen
    T01 = transformation_matrix(L['world']['l'] + L['hop']['l'], L['base']['l'], 0, theta1_rad)
    T12 = transformation_matrix(L['lower_arm']['l'], 0, -np.pi / 2, theta2_rad)
    T23 = transformation_matrix(L['upper_arm']['l'], 0, 0, theta3_rad)

    T03 = T01 @ T12 @ T23

    T03Rot = np.array ([
        [T03[0, 0], T03[0, 1], T03[0, 2]],
        [T03[1, 0], T03[1,1], T03[1,2]],
        [T03[2,0], T03[2,1], T03[2,2]]
    ])

    # Vi bestemmer vores transformation for alle vores DH parametere og fjerner T03 så vi kune har T36W tilbage
    T06W = np.linalg.multi_dot([transformation_matrix(d['d'],d['a'], d['alpha'],d['theta']) for d in dh_params])

    T06Rot = np.array([
        [T06W[0, 0], T06W[0, 1], T06W[0, 2]],
        [T06W[1, 0], T06W[1, 1], T06W[1, 2]],
        [T06W[2, 0], T06W[2, 1], T06W[2, 2]]
    ])

    Rot01 = T06Rot @ R
    RotMax = np.linalg.inv(T03Rot) @ Rot01

    #Vi udregner vores roll, pitch og yaw
    Beta = np.arctan2(-RotMax[2, 0], np.sqrt(RotMax[0, 0]**2+RotMax[1, 0]**2))
    Alpha = np.arctan2(RotMax[0, 1]/np.cos(Beta), (RotMax[0, 0]/np.cos(Beta)))
    Gamma = np.arctan2(RotMax[1, 2]/np.cos(Beta), (RotMax[2, 2]/np.cos(Beta)))

    print ("Beta:", np.degrees(Beta))
    print ("Alpha:", np.degrees(Alpha))
    print ("Gamma:", np.degrees(Gamma))


    # Udregning af theta 4, 5 og 6 - begge løsninger
    #theta5_rad_1 = np.arccos(RotMax[1][2])
    #theta5_rad_2 = -theta5_rad_1  # Spejlvendt løsning

    theta5sin = np.sqrt(RotMax[0, 1]**2 + RotMax[1, 1]**2)
    theta5_rad_1 = np.arctan2(theta5sin, RotMax[1, 2])
    theta5_rad_2 = -theta5_rad_1  # Spejlvendt løsning
    # Første løsning
    theta4_rad_1 = np.arctan2(RotMax[0][2] * -np.sin(theta5_rad_1), -RotMax[2][2] * np.sin(theta5_rad_1))
    theta6_rad_1 = np.arctan2(-RotMax[1][0] * np.sin(theta5_rad_1), RotMax[1][1] * np.sin(theta5_rad_1))

    # Anden løsning
    theta4_rad_2 = np.arctan2(RotMax[0][2] * -np.sin(theta5_rad_2), -RotMax[2][2] * np.sin(theta5_rad_2))
    theta6_rad_2 = np.arctan2(-RotMax[1][0] * np.sin(theta5_rad_2), RotMax[1][1] * np.sin(theta5_rad_2))

    # Konverter til grader
    theta4_deg_1 = np.degrees(theta4_rad_1)
    theta5_deg_1 = np.degrees(theta5_rad_1)
    theta6_deg_1 = np.degrees(theta6_rad_1)

    theta4_deg_2 = np.degrees(theta4_rad_2)
    theta5_deg_2 = np.degrees(theta5_rad_2)
    theta6_deg_2 = np.degrees(theta6_rad_2)

    return (float(theta1_deg), float(theta2_deg), float(theta3_deg),
            (float(theta4_deg_1), float(theta4_deg_2)),
            (float(theta5_deg_1), float(theta5_deg_2)),
            (float(theta6_deg_1), float(theta6_deg_2)))


# Definer desired position ud fra x, y, z og vores roll, pitch og yaw
desired_position = (272, 127, 103)

# Udregning af inverse kinematik
theta1_deg, theta2_deg, theta3_deg, theta4_deg, theta5_deg, theta6_deg = geometric_inverse_kinematic(desired_position, L)

# Print for theta værdierne
print("Theta values for Inverse Kinematic:")
print("Theta1 in Degrees:", theta1_deg)
print("Theta2 in Degrees:", theta2_deg)
print("Theta3 in Degrees:", theta3_deg)
print("Theta4 in Degrees: ", theta4_deg)
print("Theta5 in Degrees:", theta5_deg)
print("Theta6 in Degrees:", theta6_deg)
