
import numpy as np

# Længder på de forskellige dele af robotten
L = {
    'world': {'l': 90},
    'hop': {'l': 45},
    'base': {'l': 45},
    'lower_arm': {'l': 95},
    'parallel_arm': {'l': 120, 's1': 30, 's2': 20},
    'elbow': {'l': 18},
    'upper_arm': {'l': 175},
    'wrist': {'l': 70}
}
# Dette er vores DH parameter taget fra vores Forward kinematik
dh_params = [
    {'theta': 0, 'd': L['world']['l'] + L['hop']['l'], 'a': L['base']['l'], 'alpha': 0},
    {'theta': 0, 'd': L['lower_arm']['l'], 'a': 0, 'alpha': -np.pi / 2},
    {'theta': 0, 'd': L['upper_arm']['l'], 'a': 0, 'alpha': 0},
    {'theta': 0, 'd': 0, 'a': L['elbow']['l'], 'alpha': -np.pi / 2},
    {'theta': 0, 'd': 0, 'a': 0, 'alpha': np.pi / 2},
    {'theta': 0, 'd': L['wrist']['l'], 'a': 0, 'alpha': -np.pi / 2}
]

# Vi begynder at udregne vores theta værdier
def geometric_inverse_kinematic(desired_position, L):
    x, y, z = desired_position

    # Udregning af theta1
    theta1_rad = np.arctan2(y, x)
    theta1_deg = np.degrees(theta1_rad)

    # Links
    L1 = L['lower_arm']['l'] + L['elbow']['l']
    L2 = L['upper_arm']['l'] + L['wrist']['l']

    # Udregn theta 2
    nyx = x-L1
    nyz = z-L['world']['l']
    theta2_rad = np.arccos((L2**2 + np.sqrt(nyx**2+nyz**2)**2 - L2**2) / (2 * L1 * np.sqrt(nyx**2+nyz**2))) + np.arctan2((z-L['world']['l']), x-L['hop']['l'])
    theta2_deg = np.degrees(theta2_rad)-90

    #Theta3 får vi fra vores forward kinematik program
    theta3_deg = 11.58
    theta3_rad = np.radians(theta3_deg)

    #Opstilling af den totale transformations matrix.
    def transformation_matrix(d, a, alpha, theta):
        return np.array([
            [np.cos(theta), -np.sin(theta), 0, a],
            [np.sin(theta) * np.cos(alpha), np.cos(theta) * np.cos(alpha), -np.sin(alpha), np.sin(alpha) * d],
            [np.sin(theta) * np.sin(alpha), np.cos(theta) * np.sin(alpha), np.cos(alpha), np.cos(alpha) * d],
            [0, 0, 0, 1]
        ])

    #Vi bestemmer de tre første rækker af vores DH og ganger dem sammen
    T01 = transformation_matrix(L['world']['l'] + L['hop']['l'], L['base']['l'], 0, theta1_rad)
    T12 = transformation_matrix(L['lower_arm']['l'], 0, -np.pi / 2, theta2_rad)
    T23 = transformation_matrix(L['upper_arm']['l'], 0, 0, theta3_rad)

    T03 = T01 @ T12 @ T23

    # Vi bestemmer vores transformation for alle vores DH parametere og fjerner T03 så vi kune har T36W tilbage
    T06W = np.linalg.multi_dot([transformation_matrix(d['d'],d['a'], d['alpha'],d['theta']) for d in dh_params])

    T36W = np.linalg.inv(T03) @ T06W

    # Udregning af theta 4, 5 og 6 - begge løsninger
    theta5_rad_1 = np.arccos(T36W[1][2])
    theta5_rad_2 = -theta5_rad_1  # Spejlvendt løsning

    # Første løsning
    theta4_rad_1 = np.arctan2(T36W[2][2] * np.sin(theta5_rad_1), -T36W[0][2] * np.sin(theta5_rad_1))
    theta6_rad_1 = np.arctan2(-T36W[1][1] * np.sin(theta5_rad_1), T36W[1][0] * np.sin(theta5_rad_1))

    # Anden løsning
    theta4_rad_2 = np.arctan2(T36W[2][2] * np.sin(theta5_rad_2), -T36W[0][2] * np.sin(theta5_rad_2))
    theta6_rad_2 = np.arctan2(-T36W[1][1] * np.sin(theta5_rad_2), T36W[1][0] * np.sin(theta5_rad_2))

    # Konverter til grader
    theta4_deg_1 = np.degrees(theta4_rad_1)
    theta5_deg_1 = np.degrees(theta5_rad_1)
    theta6_deg_1 = np.degrees(theta6_rad_1)

    theta4_deg_2 = np.degrees(theta4_rad_2)
    theta5_deg_2 = np.degrees(theta5_rad_2)
    theta6_deg_2 = np.degrees(theta6_rad_2)

    return (float(theta1_deg), float(theta2_deg), float(theta3_deg),
            (float(theta4_deg_1), float(theta4_deg_2)),
            (float(theta5_deg_1), float(theta5_deg_2)),
            (float(theta6_deg_1), float(theta6_deg_2)))


# Definer desired position ud fra x, y og z værdier
desired_position = (-105, 270, 105)

def convert_to_servo_range(theta_deg):
    return max(0, min(180, theta_deg + 90))

# Udregning af inverse kinematik
theta1_deg, theta2_deg, theta3_deg, theta4_deg, theta5_deg, theta6_deg = geometric_inverse_kinematic(desired_position, L)

# Konvertering af theta værdier
theta1_servo = convert_to_servo_range(theta1_deg)
theta2_servo = convert_to_servo_range(theta2_deg)
theta3_servo = convert_to_servo_range(theta3_deg)
theta4_servo_1 = convert_to_servo_range(theta4_deg[0])
theta4_servo_2 = convert_to_servo_range(theta4_deg[1])
theta5_servo_1 = convert_to_servo_range(theta5_deg[0])
theta5_servo_2 = convert_to_servo_range(theta5_deg[1])
theta6_servo_1 = convert_to_servo_range(theta6_deg[0])
theta6_servo_2 = convert_to_servo_range(theta6_deg[1])

# Print for theta værdierne
print("Theta values for Inverse Kinematic:")
print("Theta1 in Degrees:", theta1_deg)
print("Theta2 in Degrees:", theta2_deg)
print("Theta3 in Degrees:", theta3_deg)
print("Theta4 in Degrees: ", theta4_deg)
print("Theta5 in Degrees:", theta5_deg)
print("Theta6 in Degrees:", theta6_deg)

print("\nConverted Theta values for Servo Range [0–180]:")
print("Theta1 Servo:", theta1_servo)
print("Theta2 Servo:", theta2_servo)
print("Theta3 Servo:", theta3_servo)
print("Theta4 Servo: ", (theta4_servo_1, theta4_servo_2))
print("Theta5 Servo:", (theta5_servo_1, theta5_servo_2))
print("Theta6 Servo:", (theta6_servo_1, theta6_servo_2))
