import numpy as np

# Define the lengths of the robot arm segments
L = {
    'world': {'l': 90},
    'base': {'l': 45},
    'lower_arm': {'l': 95},
    'parallel_arm': {'l': 120, 's1': 30, 's2': 20},
    'elbow': {'l': 18},
    'upper_arm': {'l': 175},
    'wrist': {'l': 70}
}

def geometric_inverse_kinematic_for_disp1_ud(desired_position, L):
    x, y, z = desired_position

    # Theta 1
    theta1_rad = np.arctan2(y, x)
    theta1_deg = np.degrees(theta1_rad)

    # Beregn afstand fra base til ønsket position (projektion på xy-plan)
    r = np.sqrt(x**2 + y**2)
    z_offset = z - L['base']['l']  # Højdeforskel fra basen til punktet

    # Brug cosine law til at finde vinkler
    a = L['lower_arm']['l'] + L['elbow']['l']  # første led + albue
    b = L['upper_arm']['l'] + L['wrist']['l']  # anden led
    c = np.sqrt(r**2 + z_offset**2)  # afstanden til målpunktet

    # Sikkerhedstjek (robotten kan ikke nå for langt væk)
    if c > (a + b):
        raise ValueError("Target is out of reach")

    # Vinkel theta2 (vinkel mellem base og første led)
    angle_a = np.arccos((b**2 + c**2 - a**2) / (2 * b * c))
    angle_b = np.arctan2(z_offset, r)
    theta2_rad = angle_b + angle_a
    theta2_deg = np.degrees(theta2_rad)

    # Vinkel theta3 (vinkel mellem første og anden led)
    angle_c = np.arccos((a**2 + b**2 - c**2) / (2 * a * b))
    theta3_deg = 180 - np.degrees(angle_c)

    # Placeholder værdier for håndled
    theta4_deg = 180
    theta5_deg = 80
    theta6_deg = 70

    return theta1_deg, theta2_deg, theta3_deg, theta4_deg, theta5_deg, theta6_deg

def geometric_inverse_kinematic_for_disp1_ind(desired_position, L):
    x, y, z = desired_position

    # Theta 1
    theta1_rad = np.arctan2(y, x)
    theta1_deg = np.degrees(theta1_rad)

    # Beregn afstand fra base til ønsket position (projektion på xy-plan)
    r = np.sqrt(x**2 + y**2)
    z_offset = z - L['base']['l']  # Højdeforskel fra basen til punktet

    # Brug cosine law til at finde vinkler
    a = L['lower_arm']['l'] + L['elbow']['l']  # første led + albue
    b = L['upper_arm']['l'] + L['wrist']['l']  # anden led
    c = np.sqrt(r**2 + z_offset**2)  # afstanden til målpunktet

    # Sikkerhedstjek
    if c > (a + b):
        raise ValueError("Target is out of reach")

    # Vinkel theta2 (vinkel mellem base og første led)
    angle_a = np.arccos((b**2 + c**2 - a**2) / (2 * b * c))
    angle_b = np.arctan2(z_offset, r)
    theta2_rad = angle_b + angle_a
    theta2_deg = np.degrees(theta2_rad)

    # Vinkel theta3 (vinkel mellem første og anden led)
    angle_c = np.arccos((a**2 + b**2 - c**2) / (2 * a * b))
    theta3_deg = 180 - np.degrees(angle_c)

    # Placeholder værdier for håndled
    theta4_deg = 0
    theta5_deg = 0
    theta6_deg = 0

    return theta1_deg, theta2_deg, theta3_deg, theta4_deg, theta5_deg, theta6_deg

# Define the desired positions
desired_position_ud = (-110, 240, 240)
desired_position_ind = (-130, 280, 240)

# Call the functions and store the results
theta_values_ud = geometric_inverse_kinematic_for_disp1_ud(desired_position_ud, L)
theta_values_ind = geometric_inverse_kinematic_for_disp1_ind(desired_position_ind, L)

# Print for disp1_ud
print("Theta values for disp1_ud:")
print("Theta1 in Degrees:", theta_values_ud[0])
print("Theta2 in Degrees:", theta_values_ud[1])
print("Theta3 in Degrees:", theta_values_ud[2])
print("Theta4 in Degrees:", theta_values_ud[3])
print("Theta5 in Degrees:", theta_values_ud[4])
print("Theta6 in Degrees:", theta_values_ud[5])

# Print for disp1_ind
print("Theta values for disp1_ind:")
print("Theta1 in Degrees:", theta_values_ind[0])
print("Theta2 in Degrees:", theta_values_ind[1])
print("Theta3 in Degrees:", theta_values_ind[2])
print("Theta4 in Degrees:", theta_values_ind[3])
print("Theta5 in Degrees:", theta_values_ind[4])
print("Theta6 in Degrees:", theta_values_ind[5])
